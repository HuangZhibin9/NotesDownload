## STL、数据结构、算法
### 1、STL具体分为哪几个部分？

- 首先我是基于GNUC2.9的STL源码学习的，他和4.9还是有挺多不同的，不过对于帮助我理解标准模板库还是2.9更好。
- STL标准模板库主要分为六个部分：最重要的三个是**容器、算法、迭代器**。另外三个是**分配器、仿函数和适配器。**
- 2.9的STL主要运用的是**泛型编程**的思想，它和我们的面向对象还是有些许不同的，**面向对象**最重要的思想是**运行时多态**，而**泛型编程**时**编译时多态**，另外面向对象通常会把数据和算法放在一个对象中，而在STL中将数据和算法分开，各自实现自己，通过迭代器链接。 
   - 容器：就是装数据的东西，容器有很多种，分别对应我们常用的数据结构，比如**序列式容器**里的数组、链表、栈、队列等和关**联式容器**里的红黑树、set和map以及哈希表
   - 迭代器：简单的说迭代器就是一个指针，当然它本质上是一个类，不过重载了指针相关的符号，**假装自己是个指针**，这个和智能指针的实现原理差不多，迭代器的作用就是指向容器中的一个数据，当然它作为一个类肯定有别的状态或者说属性，比如说一个迭代器首先要**定义的五个东西**，**迭代器的分类、迭代器之间的距离用什么单位、迭代器里数值的类型**，还有一个point和reference，但是这两个在源码中没有用过我也不知道用来干嘛的，主要还是前三个定义，这是**迭代器要回答算法的三个问题。**
   - 算法：算法就是**通过迭代器访问容器里的数据**，对他们**进行操作**，前面说了迭代器作用就是一个指针，算法通过这个指针得到数据，但除此之外，算法还需要知道一些关于迭代器的细节，就是刚刚说的那三个问题三个定义，迭代器的类型和数值的类型等等，知道这些东西算法可以选择性能更好或者说更匹配的实现方式。比如知道迭代器是一个随机访问的迭代器，排序算法就可以选择快速排序，而如果是一个链表不支持随机访问，就需要其他办法。算法如何问这三个问题是通过萃取机traits，具体怎么实现我就不赘述了。
   - 剩下三个是**分配器、仿函数和适配器**，分配器就是为容器分配空间的东西，也是我们创建容器的时候需要的**第二个模板参数**，虽然我们通常不设置，使用默认的分配器，在4.9的版本中分配器就是简单的调用operator new和operator delete函数，没什么多的设计，但是**2.9的分配器就使用了内存池的设计**，当然我这里也不多说了。仿函数的话就是一个类对象重载了小括号，假装他自己是一个函数，使用起来和函数也差不多，不过和智能指针一样，它可以比函数有额外的状态或者说元素之类的，比如我可以设置在内部记录这个函数调用多少次等等，适配器其实就是改造器，把一个东西改造成另一个东西，常见的有算法适配器，容器适配器等等，比如stack和queue就是一个容器适配器，是改造了deque的，另外这两个东西也挺有意思，他们不仅可以通过deque实现也能通过链表等，不过我对于适配器的了解不是很深，用的也不多，所以可能有些东西我也不太懂。
### 2、STL各种容器的底层实现？

-  vector 
   - vector是一个模板类，两个模板参数，第一个是数据类型，第二个是分配器。底层**数据结构就是一个数组**，类**本身包含三个指针**，所有vector的相关操作都是由这三个指针实现的，分别为**start**，指向数组的首地址，**finish**，指向数组有效长度的末尾，**end of storage**，数组容量的末尾，也就是实际上vector的迭代器就是指针，其他容器的迭代器则是一个类，这里涉及到了算法用萃取机traits读取迭代器信息，它有一个特化版本就是当迭代器是一个指针的时候，就是为vector设计的。vector与数组不同的地方就在于vector可以动态扩容，我们就不再需要给数组一个初始的容量，然后再烦恼扩容的事情了。在vector中，插入数据时会检查容量是否已满，容量已满，也就是finish等于end of storage时，就会进行扩容，一般是两倍或者1.5倍，再VS中是两倍，gnuc中式1.5倍。扩容是申请一片新的连续空间，把原来的数据拷贝过来，再把原来的空间释放掉。
-  list 
   - list的**底层数据结构就是一个双向循环链表**，但实际上list本身是由一个指针组成，这个指针指向实际的链表的头节点，每个节点包含前向指针后向指针和值，list的迭代器就包含一个指向这种节点的指针，同时为了模拟指针的操作，迭代器还重载了++和--等符号，当然如果是forward_list单项链表就没有--了。另外刚刚说的list容器中包含一个指向链表头节点的指针，这个头节点是没有数据的一个头部，真正的开始是它的下一个节点，也就是list的begin()函数实际返回的就是这个指针+1，而因为list是一个循环链表，所以实际上这个头部也是链表的尾部，也就是end()函数返回的实际就是这个指针。此外的话list因为迭代器没有重载中括号和+号也就是说list的迭代器不支持随机访问，因为链表本身就不支持随机访问。
-  deque 
   - deque，也就是双端数组，也是一个模板类，但是他有**三个模板参数，数据类型，分配器，最后是一个buffer的大小**。首先deque作为数组肯定是要连续存储的，但是deque的**连续存储只是对外号称**的，实际上它的底层并不是连续存储，而是**分段存储**，只是**依靠复杂的迭代器结构**来假装自己是个连续存储的数据结构。具体实现手段就是，首先有一个**控制中心map**，这个map不是容器的那个map，这个map实际上是一个vector容器，里面存放的是**指向每个缓冲区的指针**，缓冲区才是一段连续的存储空间，上面存放实际的数据。而deque本身包含的是两个迭代器，分别指向头和尾用来返回begin和end，然后是一个map指针，然后是map_size，也就是说我们存放一个数据，**实际上是先通过deque的map指针找到map，在map中找到实际的buffer地址，再把数据存放到buffer里面。**然后就是迭代器的设计了，迭代器的设计就是deque的关键之处，首先**迭代器里面有四个元素**，一个**node指针**，指向map中的一个值，也就是表示这个迭代器是属于哪一个buffer，后面两个元素分别是**first和last**，分别对应指向这个buffer的头和尾，最后一个指针**curent**，指向它实际存放在buffer中的位置。然后就是运算符的重载了，比如++，设计了假如目前current等于last，说明当前buffer用完了，它就要转到下一个buffer，下一个buffer没有，就要申请一片空间作为下一个buffer，又比如+号，一个指针加多少，先计算它会跳过几个buffer，调整node指针到对应的buffer，在计算它在这个buffer的实际位置。另外刚刚说的三个模板参数最后一个是**一个buffer的大小，但是我上次看了一下，好像现在是不能设置，默认为512字节除以每个元素的大小**，就是一个buffer的大小。还有就是装着map的vector容器，以为需要push_front，map的指针实际是放在中间的，这样前后都能扩展，无论前还是后到头了，就会对vector扩容，再把指针放在vector中间。
-  stack、queue 
   - stack、queue，首先看这两个容器的**模板参数**就能发现有意思的东西，第一个是数值类型，第二个就是一个**底层结构类**，默认是deque。这意思是实际上stack和queue是一个**容器适配器**，通过改造其他容器完成自己需要的功能，比如deque，就是在栈和队列里面组合了一个deque，也就是包含了一个deque，他能使用deque的所有接口，但是实际上它们只需要一部分，比如stack只需要pop栈顶元素，也就是它只开放deque的pop_back函数，同理队列也是，就是说它通过只开放一部分duque的接口，并改成自己的名字作为自己的接口。然后就是默认是deque，意味着也可以使用其他的容器，就看他需要使用的是哪个接口，比如栈需要的是pop_back等，除了deque还有list和vector都可以完成，所以他也可以用list和vector作为它的底层结构，然后就是queue，他需要的是弹出队首元素，pop_front，这个只有list和deque能做到了。最后想说的是，这里运用了一个思想就是组合，一个类里面包含了另一个类，在能使用另一个类的接口同时，不破坏封装性，这是很优秀的，相比继承就会破坏封装性，但是实际上继承要完成的是多态，这个和设计模式中的优先使用组合而不是继承的原则相符合。
-  RB_Tree 
   - 搜索： 
      - 线性搜索：O(n)
      - 二分搜索：O(log n) 
         - 插入元素就需要考虑位置，需要移动数据，效率低
      - 二叉查找树（BST）：O(log n) 
         - 如果退化成链表，查找效率很低 O(n)
      - 二叉平衡树（AVL）：O(log n) 
         - RR ：左旋
         - LL：右旋
         - LR：先左旋在右旋
         - RL：先右旋再左旋
         - 插入调整太浪费时间
      - 红黑树（RBT）：O(2*log2(n +1)) 
         - 每个节点不是红色就是黑色
         - 根节点是黑色
         - 父子不能都是红色，但是可以两个黑色
         - 到每个孩子的黑色节点数相同
         - 红黑树的高度最多是2*log2(n +1)
   - 红黑树是一种高度平衡的二叉搜索树，有利于查找，在STL中也是有这个容器的，但是已经被set和map取代了，也不是说取代吧，就是set和map底层其实就是一个红黑树，就和栈和队列一样是一个容器适配器。红黑树有五个模板参数，**key的类型**，也就是键值对中的键，用来排序作为标识的，**第二个是value的类型**，这个value是键值对的类型，也就是key加上data合起来是一个value，**第三个是如何从value中取出key**，然后是**比较方法和分配器。**红黑树提供两种插入方式，unique也就是重复的被舍弃不会重复插入，第二个是equal，重复的话插入到相邻位置。然后就是红黑树的value值不应该被改动，会破坏红黑树的排列结构，但实际编程上并没有阻止修改，就是说如果修改编译器并不会报错，但是这只是因为map中需要修改data的值，但是对于key我们是不能更改的。
-  set、multiset 
   - 首先set的所有操作都是转调红黑树的接口，也就是所谓的**容器适配器**，在set内部有一个红黑树。在前面说的红黑树的模板参数中，系统会自动帮我们设置，第一个key的类型也就是我们设置的set的key类型，value类型就是key类型，因为set是没有data的，key就是value，如何从value中取出key，因为value就是key所以传入什么就传出什么，然后是比较方法，，一般是在key是我们自定义类型的时候使用，告诉容器如何比较。因为底层是红黑树，我们插入数据后会自动排序，且查找的效率很高，时间复杂度为log n，另外set是不允许插入重复的，也不是不允许，就是如果插入重复的就什么都不会做，因为内部调用的是RBtree的insert unique方法，而multiset就是equal方法，会在相邻的地方插入。
   - 关于set和map中**不允许修改key值**的设计还是有些许不同的，在set中是因为set的**迭代器直接设计成了一个const迭代器**，这样我们就无法修改这个迭代器了，而在map中，因为我们还是**需要通过迭代器修改data的值**所以不能将迭代器设置为const，而是在底层传输红黑树**模板参数的value类型中进行了限定**，本来我们设计map传入的模板参数应该是两个类型，而在map内部会帮我们在传给红黑树的时候在**key的类型前加上const**，这样我们就无法修改key值，但是能修改data值。
-  map、multimap 
   - 大致与set相同，唯一的区别就是里面的value分为key和data，也就是除了用于排序的key，还有数据部分，在底层红黑树的模板参数中value的类型就不再是key而是一个键值对，如何得到key，就变成的返回value的first，另外map比set的多设计的地方就是map**重载了【】**，这样是我们可以通过key值查找data值，另外如果【】中是不存在的key，则会创建一个key为【】内的数值的pair存入map中，data默认应该是0，所以我们也可以利用中括号进行insert。
-  hashtable 
   - hashtable和RBtree一样都是模板库中的幕后英雄吧，我们都不必直接用它，而是使用它们的上层set和map，但是实际上源码中就有它们，我们也是能够直接使用它们的，hashtable的模板参数有六个，**value类型**，**key的类型**，**哈希函数**，**如何取出key**，比较大小和分配器，比红黑树多的实际上就只有一个哈希函数，就是如何把对象转换成哈希值，hashtable 内部实际的数据载体就是一个vector容器的bucket，里面装的指向对象的指针，使用的是拉链法解决哈希碰撞。
   - 拉链法，把所有冲突的对象放在一个链表上，当我们查找这个哈希值时，就查找这个链表上的数据
   - 开放定址法：在拉链法中我们哈希表中的空闲地址只对当前哈希值开放，冲突就挂在同一链表上，而开放定址法中的空闲地址即对该哈希值开放，也对其他值开放，具体的实现过程就是当我们一个数据第i次发生冲突时，在这个哈希值的基础上加上一个增量di，然后对表长取余，然后把数据存放在该位置，这个增量由三种取法，分别为线性探测法和平方探测法和伪随机序列法。 
      - 线性探测法，就是di = 0，1，2依次往后，意思其实就是发生冲突时，依次探测后面的一个位置有没有数据，没有就把数据存放进去，如果在冲突，就再往后探测。而查找就是先查找对应位置的key，不是就往下查找，直到找到或者到第一个空位置，才算查找完成，但是这样除了要排除同义词，还需要排除非同义词，所以其实就是一种用时间换空间的方法。另外在删除一个值的时候，还不能直接删除，因为在刚刚说查找的时候，查找到第一个空位置就宣布查找完毕，如果中间删除了，就有可能提前终止查找，所以就需要使用一个bool标志，标识当前位置是否删除。
      - 这种方法会造成同义词非同义词堆积，影响查找效率，所以现在一般使用的是拉链法。
      - 平方探测法，就是di为1，-1，4，-4，9，-9。
-  unordered_set\map 
   - 这两个实际上的底层数据结构就是hashtable，不过我们在使用set和map是，系统帮我们做了很多事，就是刚刚说的hashtable中的六个模板参数，由系统设置了大部分，我们只需要给的是set的key类型和map的pair类型，而另外的如何取key，以及哈希函数都由已经设置好了，此外的使用方式就和set和map一样了。
### 3、STL各种容器的查找、删除和插入的时间复杂度（性能比较）？

-  vector支持随机访问，通过下表查找复杂度O(1)，无序查找O(n)，有序二分查找O(log n)，插入操作尾插最快，不需要搬动数据，当然如果需要扩容就有很大的时间开销，中间次之，头插最慢。另外vector由于是数组存放，会有空闲空间也就是会有很大的内存开销，由于二倍扩容，内存不足时候的拷贝操作也会有较大的性能开销。 
-  list底层是链表，不支持随机访问，只能通过顺序查找，但是插入和删除速度快，只需要调整指针的指向。但是也有一种说法是list插入和删除需要内存的分配和释放，有较大的性能开销，这一点我也不是很清楚，但是但从链表来看的话，插入删除肯定是更快的。另外list没有内存的浪费，占用内存较小。 
-  deque支持随机访问，但是性能比vector低，这里我觉得应该是由于deque的迭代器比较复杂，查找一个对象，需要先在map中找到对应的buffer，在进入buffer找到对应的位置。其他和vector一样，头尾删插快，中间慢。 
-  set和map，底层基于红黑树实现，增删查改的时间复杂度近似O(log n)，红黑树又是基于链表实现，因此占用内存较小； 
-  unordered_set和unordered_map，底层是基于哈希表实现的，是无序的。理论上增删查改的时间复杂度是O(1)（最差时间复杂度O(n))，实际上数据的分布是否均匀会极大影响容器的性能。 
### 4、STL怎么做内存管理的，Allocator次级分配器的原理，内存池的优势和劣势？

- 在gnuC 2.9中使用的是内存池管理技术，但是在4.9中回调为没有任何额外设计的普通operator new和delete内存分配了，内存池管理使用了两级配置器，分配空间大于128时，直接使用malloc和free申请空间，而在0-128B使用内存池分配，具体实现是 分配器维护了一个装有16条自由链表的数组，每条链表对应8，16，24，一直到128大小的内存空间，当要申请对应大小的空间时，就到对应的自由链表查看是否还有空闲空间可以分配，没有的话再查看备用池中是否由空闲空间，如果没有，就一次申请40块内存，每块大小为对应申请的大小，其中二十块放在对应的自由链表下，另外20块放在备用池中，下次再申请这个大小的空间，就能再链表下使用剩下的19块，而其他大小也会去查看备用池，里面还有20块内存，这20块会根据当前需要的大小重新切块并放在对应链表下。
- 优势：减少cookie提高内存的使用率减少浪费，减少分配内存的次数，性能提高
- 劣势：会产生内部碎片，不足八字节的也需要分配8字节
### 5、STL容器的push_back和emplace_back的区别？

- 两者为的不同在于，当我们传入的是类型构造需要的参数时，push_back会先以这个参数构造一个临时对象，再把这个临时对象拷贝或者移动到容器中，而emplace_back是直接在容器内构造对象，比如我们有一个自定义类型，有一个int参数的构造函数，然后我们push_back一个int，则会以这个int为参数，构造一个临时对象再拷贝，而emplace_back就是直接在容器中，以这个int参数构造一个对象。
### 6、**STL的排序用到了哪种算法，具体如何执行**？

- 使用的排序方法是快速排序、插入排序、堆排序。
- 在数据量很大时采用正常的快速排序，此时效率为O(logN)。
- 一旦**分段后的数据量小于某个阈值**，就改用插入排序，因为此时这个分段是基本有序的，这时效率可达O(N)。
- 在递归过程中，如果递归层次过深，**分割行为有恶化倾向时**，它能够自动侦测出来，使用堆排序来处理，在此情况下，使其效率维持在堆排序的O(N logN)，但这又比一开始使用堆排序好
