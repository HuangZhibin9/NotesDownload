# C++11新特性

## 1 智能指针

- 三种 
  - `std::unique_ptr`
  - `std::shared_ptr`
  - `std::weak_ptr`

### `unique_ptr`定义

- 在任何给定的时刻，只能有一个指针管理内存

- 当指针超出作用域时，内存将自动释放

- 该类型指针不可以copy，只能move

- 三种创建方式

  - 通过已有裸指针创建

  ```c++
  Cat *c_p1 = new Cat("xy");
  std::unique_ptr<Cat> u_c{c_p2};
  //注意此时c_p1还能用，独占指针不独占，应该要销毁原始指针
  c_p1 = nullptr;
  delete c_p1;
  ```

  - 通过new来创建

  ```
  std::unique_ptr<Cat> u_c{new Cat("dd")};
  ```

  - 通过`std::make_unique`创建（推荐）(c++ 14 加入)

  ```
  std::unique_ptr<Cat> u_c = make_unique<Cat>();
  ```

- `unique_ptr`可以通过get()获取地址

- `unique_ptr`实现了->与*

  - 可以通过->调用成员函数
  - 可以通过*调用dereferencing

- 裸指针和`unique_ptr`的区别

  - 裸指针指向new的内存，需要自己手动释放
  - `unique_ptr`会在生命周期结束的时候自动释放

- 函数调用`unique_ptr`

  - pass by value 

    - 必须转化成右值引用传递过去，如果传递左值，会提示`unique_ptr`的拷贝构造函数已经被删除，这里看源码可以知道`unique_ptr`的拷贝构造函数已经 `=delete`了，所以只能使用它的移动构造函数，也就是把它move成为右值传递过去，它的内存所有权就被函数的局部变量`unique_ptr`接收了，函数结束就被析构了，也就以为着函数结束之后，我们一开始的`unique_ptr`也不能再用了

    - ```c++
      void do_with_Cat(unique_ptr<Cat> s) {
          s->CatInfo();
      }
      
      int main() {
      
          std::unique_ptr<Cat> u_c = make_unique<Cat>("ff");
          do_with_Cat(std::move(u_c));//用move转化成右值
          //u_c->CatInfo(); 会报错
          system("pause");
      }
      ```

  - pass by reference

    - 直接传递当前`unique_ptr`的左值引用过去，跟正常函数传递引用是一样的，直接在指针上进行操作，在函数内对指针进行reset后，原指针也变为空，若是传递引用前加上const，则该指针就不能改变指向，不能reset，但是还是能改变指针里面的值

    - ```c++
      void do_with_Cat(const unique_ptr<Cat> &s) {
          s->CatInfo();
          s->SetInfo("ssss");//能通过内置函数改变值
          //s.reset(); 但是改变指向报错
      
          /*Cat* tmp = new Cat{ "ss" };
          s.reset(tmp);     reset可以改变指向
          tmp->CatInfo();
          delete tmp;*/
          
      }
      
      
      int main() {
      
          std::unique_ptr<Cat> u_c = make_unique<Cat>("ff");
          do_with_Cat(u_c);
          u_c->CatInfo();
          system("pause");
      
      }
      ```

### `shared_ptr`

- 计数指针、共享指针
- 与`unique_ptr`不同的是它是可以共享数据的
- `shared_ptr`创建了一个计数器与类对象所指的内存相关联
- Copy则计数器加一，销毁则计数器减一
- api为`use_count()`

```c++
shared_ptr<int> _s_p_1 = make_shared<int>(10);
cout << "_s_p_1 的use_count:" << _s_p_1.use_count() << endl;
cout << endl;

    //copy    创建另一个指针指向同一个地址  use_count +1
shared_ptr<int> _s_p_2 = _s_p_1;
cout << "_s_p_1 的use_count:" << _s_p_1.use_count() << endl;
cout << "_s_p_2 的use_count:" << _s_p_2.use_count() << endl;
cout << endl;

    //change    因为两指针共享一份数据，一个改另一个也改
*_s_p_2 = 30;
cout << "_s_p_1 的value:" << *_s_p_1 << endl;
cout << "_s_p_2 的value:" << *_s_p_2 << endl;
cout << endl;

    //address   因为两指针共享一份数据，存储的地址相同
cout << "_s_p_1 的value:" << _s_p_1 << endl;
cout << "_s_p_2 的value:" << _s_p_2 << endl;
cout << endl;

    //delete   只清理掉_s_P_1，2还在
_s_p_1 = nullptr;
cout << "_s_p_1 的use_count:" << _s_p_1.use_count() << endl;
cout << "_s_p_2 的use_count:" << _s_p_2.use_count() << endl;
cout << endl;
```

- 只有没人指向这块数据的时候，这块数据才会调用delete

- pass by value
  - 可以传递，会调用copy创建一个局部指针与外指针共享一份数据，结束作用域销毁，即在作用域内，use_count +1,结束use_count -1
  - 但是因为内外指针共享一个数据，函数内部修改数据，对外界也有影响，但是两个指针不是同一个，对指针的操作不影响外指针，比如在函数内部reset

- pass by reference
  - 就是传递该指针的引用，对指针的操作也会影响外指针，reset之后，外指针也影响
  - 加上const， 就是无法修改指针

### `shared_ptr`与`unique_ptr`

- 不能讲`shared_ptr`转换为`unique_ptr`，但是反过来可以，通过`std::move`

```c++
unique_ptr<Cat> u_p = make_unique<Cat>("ss");
shared_ptr<Cat> s_p = std::move(u_p);//将u_p转化为右值

//共享指针能接受返回值为独占指针的函数
template<class T>
unique_ptr<T> func() {
    unique_ptr<T> u_p = make_unique<T>("ss");
    return u_p;
}

int main () {
    shared_ptr<Cat> s_p = func<Cat>();
}
```

### `weak_ptr`

- 弱引用

- `weak_ptr`并不拥有所有权
- 不能调用->和解引用 *
- A类中有一个需求需要存储其他A类对象的信息
- 如果使用shared_ptr，那么在销毁时会遇到**循环依赖**问题（Cyclic dependency problem)·所以我们这里需要用一个不需要拥有所有权的指针来标记该同类对象
- weak_ptr可以通过lock()函数来提升为shared ptr(类型装换)

- 为什么要使用weak_ptr
  - 循环依赖的时候`shared_ptr`无法正常释放内存，假如一个类对象中引用了另一个对象，这种类关系叫做委托，这种类销毁的时候需要先销毁成员在销毁自己，这个时候如果两个类互相引用，在各自销毁的时候有需要先销毁对方，这就形成了一个死循环导致无法正常释放内存
  - 使用·`weak_ptr`可以解决这个问题，`weak_ptr`没有所有权，无法调用指向对象的成员（除了use_count函数），只能通过创建一个临时的`shared_ptr`来调用对方的成员，建立临时管理权。

### auto_ptr原理及仿写

- 不允许隐式构造
- 不能将同一个裸指针赋值给多个智能指针，因为他会重复释放
- 释放空间使用的是delete

```c++
template<class T>
class My_auto_ptr {
public:
    //传入指针的构造函数，默认值为nullptr，禁止隐式转换
	explicit My_auto_ptr(T* ptr = nullptr) : m_ptr(ptr) { 
        //把原指针置空，否则原指针仍然能用
        ptr = nullptr; 
    }
    //拷贝构造函数，把原对象置空
	My_auto_ptr(const My_auto_ptr& src) {
		m_ptr = src.m_ptr;
		src.m_ptr = nullptr;
	}
    //拷贝赋值函数
	My_auto_ptr& operator=(const My_auto_ptr& src) {
        //检查是否是自身
		if (src == *this) return *this;
		m_ptr = src.m_ptr;
		src.m_ptr = nullptr;
		return *this;
	}
    //析构函数
	~My_auto_ptr() {
        //在析构函数中释放指针
		delete m_ptr;
		m_ptr = nullptr;
	}
    //get函数，返回内部指针地址
	T* get() {
		return m_ptr;
	}
    //将智能指针释放，退化为裸指针返回
	T* release() {
		T* ptr = m_ptr;
		m_ptr = nullptr;
		return ptr;
	}
    //将智能指针原内存释放，并重置为新指针，默认为nullptr
	void reset(T* ptr = nullptr) {
		delete m_ptr;
        m_ptr = ptr;
		ptr = nullptr;
	}
    //重载*，返回指针内容
	T& operator*() const {
		return *m_ptr;
	}
    //重载->返回指针
	T* operator->() const {
		return (&**this);
	}
private:
	T* m_ptr;
};

```

### unique_ptr的原理及仿写

- 独占指针只允许有一份指针指向这份数据,不能将同一个裸指针赋值给多个智能指针
- 也就是在这个模板类里面，拷贝构造和拷贝赋值函数都被删除了，不允许调用，智能移动构造和移动赋值
- 独占指针不允许隐式构造
- 提供了bool运算符重载
- 释放内存使用的是deleter（删除器），里面会判断delete或者delete[]

```c++
template<class T>
class MyUnique_ptr {
private:
    //私有的内部实际指针
	T* m_ptr;
public:
    //以裸指针构造独占指针，默认为nullptr
    //禁止隐式构造
	explicit MyUnique_ptr(T* ptr = nullptr) : m_ptr(ptr) { 
		ptr = nullptr;
	}
    //因为独占指针只允许有一个指针占有实际内存
    //因此删除拷贝构造和拷贝赋值函数
    MyUnique_ptr(const MyUnique_ptr& src) = delete; 
    MyUnique_ptr& operator=(MyUnique_ptr& src) = delete;
    //移动构造函数
	MyUnique_ptr(MyUnique_ptr&& src) {
		m_ptr = src.m_ptr;
		src.m_ptr = nullptr;
	}
    //移动赋值函数
	MyUnique_ptr& operator=(MyUnique_ptr&& src) {
		if (&src == this) return *this;
		m_ptr = src.m_ptr;
		src.m_ptr = nullptr;
		return *this;
	}
    //析构函数，释放指针
	~MyUnique_ptr() {
		delete m_ptr;
		m_ptr = nullptr;
	}
    //返回内部指针地址
	T* get() {
		return m_ptr;
	}
    //销毁独占指针，取出裸指针
	T* release() {
		T* ptr = m_ptr;
		m_ptr = nullptr;
		return ptr;
	}
    //重置独占指针
	void reset(T* ptr = nullptr) {
		delete m_ptr;
		m_ptr = ptr;
		ptr = nullptr;
	}
    //交换两个指针，成员函数
    void swap(MyUnique_ptr<T>& src) {
        T* temp;
        temp = src.m_ptr;
        src.m_ptr = m_ptr;
        m_ptr = temp;
    }
    //重载*
	T& operator*() const {
		return *m_ptr;
	}
    //重载->
	T* operator->() const {
		return (&**this);
	}
    //转换函数，重载bool，用在if(u_ptr){}
	operator bool() const {
		return m_ptr != nullptr;
	}
    //声明友元函数
	template<class U>
	friend void swap(MyUnique_ptr<U>& a, MyUnique_ptr<U>& b);
};
//全局函数，用指针make_MyUnique
template<class T>
MyUnique_ptr<T> make_MyUnique(T* ptr = nullptr) {
	return MyUnique_ptr<T>(ptr);
}
//全局函数，有右值引用make_MyUnique
template<class T>
MyUnique_ptr<T> make_MyUnique(MyUnique_ptr<T>&& src) {
	return MyUnique_ptr<T>(forward<MyUnique_ptr<T>>(src));
}
//交换两个独占指针,全局函数
template<class T>
void swap(MyUnique_ptr<T>& a, MyUnique_ptr<T>& b) {
	T* temp;
	temp = a.m_ptr;
	a.m_ptr = b.m_ptr;
	b.m_ptr = temp;
}
```

### shared_ptr的原理及仿写

- 共享指针允许多个指针指向同一份数据，因为它使用了引用计数，每多一个指针指向这个数据，引用技术加一，每销毁一个指针，引用技术减一，如果引用计数为0，则delete这个数据。
- 但是共享指针也不能将同一个裸指针赋值给多个智能指针，因为这样会是两个独立的共享指针，它们会分别计数，也就是意味着到时候它们会重复释放。

```c++
template<typename T>
class MyShared_ptr {
private:
    //内部指针
	T* m_ptr;
    //计数器
	long* m_count;
public:
    //以裸指针构造共享指针，默认为nullptr
    //禁止隐式构造
	explicit MyShared_ptr(T* ptr = nullptr) : m_ptr(ptr) {
        //计数器初始化为1
		m_count = new long(1);
	}
    //以MyUnique_ptr右值构造共享指针
	MyShared_ptr(MyUnique_ptr<T>&& src) {
        //销毁独占指针，取出裸指针
		m_ptr = src.release();
        //计数器初始化为1
		m_count = new long(1);
	}
    //拷贝构造函数
	MyShared_ptr(const MyShared_ptr& src) {
		m_ptr = src.m_ptr;
        //拷贝计数器指针
		m_count = src.m_count;
        //计数器加一
		(*m_count)++;
	}
    //拷贝赋值
	MyShared_ptr& operator=(const MyShared_ptr& src) {
		if (&src == this) return *this;
        //如果自身不为空，先调用析构函数
		if (m_ptr != nullptr) {
			this->~MyShared_ptr();
		}
		m_ptr = src.m_ptr;
		m_count = src.m_count;
		(*m_count)++;
		return *this;
	}
    //以MyUnique_ptr右值 拷贝赋值
	MyShared_ptr& operator=(const MyUnique_ptr<T>&& src) {
		if (m_ptr != nullptr) {
			this->~MyShared_ptr();
		}
        //销毁独占指针，取出裸指针
		m_ptr = src.release();
		m_count = new long(1);
		return *this;
	}
    //析构函数
	~MyShared_ptr() {
        //计数器减一
		(*m_count)--;
        //如果计数器为0，则释放指针空间和计数器空间
		if (0 == *m_count) {
			delete m_ptr;
			delete m_count;
			m_ptr = nullptr;
			m_count = nullptr;
		}
	}
    //获得内部指针地址
	T* get() {
		return m_ptr;
	}
    //重置指针
	void reset(T* ptr = nullptr) {
        //先调用析构函数
		this->~MyShared_ptr();
		m_ptr = ptr;
		m_count = new long(1);
	}
    //返回当前引用计数
	long use_count() {
		return *m_count;
	}
    //转换函数 bool
	operator bool() const {
		return m_ptr != nullptr;
	}
    //当前共享指针是否唯一
	bool unique() {
		if (1 == *m_count) return true;
		else return false;
	}
    //成员函数交换指针和计数器
	void swap(MyShared_ptr<T>& src) {
		T* temp_ptr;
		long* temp_count;
		temp_ptr = src.m_ptr;
		temp_count = src.m_count;
		src.m_ptr = m_ptr;
		src.m_count = m_count;
		m_ptr = temp_ptr;
		m_count = temp_count;
	}
    //重载*
	T& operator*() const {
		return *m_ptr;
	}
    //重载->
	T* operator->() const {
		return (&**this);
	}
};
```



## 2 auto的基本使用

- auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。
- 从这个意义上讲，auto并非一种“类型”声明，而是一个类型声明时的**“占位符”**，编译器在**编译时期**会将auto**替换为变量实际的类型**。
- 配合模板类非常好用



- 1、auto定义变量必须初始化

  - ```c++
    auto a;
    a = 10;//报错
    ```

- 2、auto函数参数，有些编译器无法通过编译（Vs2013不行）

  - ```c++
    void fun(auto x =1) {}//报错
    ```

- 3、auto非静态成员变量，无法通过编译（但其实静态成员变量也不行，因为静态成员变量不能在类内初始化）

  - ```c++
    struct str
    {
        auto var = 10;   // 报错
    };
    ```

- 4、auto模板参数（实例化时），无法通过编译

  - ```c++
    vector<auto> x = {1};//报错
    ```

- 5、auto数组，无法通过编译（数组的初始化是在运行期间完成的，而auto 是在编译期间就完成的）

  - auto不能定义数组，可以定义指针

  - ```c++
    char x[3];
    auto y = x;//报错  ？？？？？？？？？有问题，是可以的
    auto z[3] = x; //报错
    
    int a[10] = {0};
    auto b = a; // ok
    ```

    

## 4 decltype

- decltype实际上有点像auto的反函数， auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到其类型

  ```c++
  #include <typeinfo>
  #include <iostream>
  #include <vector>
  using namespace std;
  
  int main()
  {
      int i;
      decltype(i) j = 0;
      cout << typeid(j).name() << endl;   // 打印出"i", g++表示integer
  
      float a;
      double b;
      decltype(a + b) c;
      cout << typeid(c).name() << endl;   // 打印出"d", g++表示double
  
      vector<int> vec;
      typedef decltype(vec.begin()) vectype; // decltype(vec.begin()) 改名为 vectype
  
      vectype k;  
      //decltype(vec.begin()) k;  
      for (k = vec.begin(); k < vec.end(); k++)
      {
          // 做一些事情
      }
  
      enum {Ok, Error, Warning}flag;   // 匿名的枚举变量
      decltype(flag) tmp = Ok;
  
      return 0;
  }
  
  ```

## 5 追踪返回值类型

- 返回类型后置：在函数名和参数列表后面指定返回类型。（C++17 后不需要写decltype）

```c++
template <typename T1, typename T2>
auto mul(const T1 & t1, const T2 & t2) -> decltype(t1 * t2)
{
    return t1 * t2;
}
```

## 6 右值引用

- 用来解决不必要的copy

- 从某些地方抓取了一些数据，这些数据会包装成临时对象，在把这些对象放到我们的容器里的时候，这就是一个copy，有的时候这种copy是非必要的，另外比如vector的扩容也是一个copy过程，当元素很多的时候copy非常浪费时间，右值引用就是用来处理非必要拷贝

- 当拷贝或者复制时，如果右手边是一个右值的时候，就可以偷右边的东西，而不必重新开辟一块内存进行拷贝

- 左值，可以出现在 = 左边的

- 右值，只能出现在 = 右边的

  - 运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。

  - 将亡值可以理解为即将要销毁的值,比如临时对象，或者你认为后面不会再用到的值（需要使用move()把它转为右值）

  - 纯右值和将亡值都属于右值。

  - ```c++
    int a = 9;
    int b = 4;
    a + b = 42;//出错
    //a+b就是一个右值，不能出现在左边，代表的是a+b这个结果的一个临时对象，这行结束就会销毁
    ```

  - 临时对象，就是一个右值，没有名称，不能出现在左边，我们不能给一个临时对象赋值

  - 但是有意思的是标准库里的`string`不遵循这个原则

    ```c++
    string s1("Hello");
    string s2("World");
    
    //尽量少使用+，+是值传递，会有一个临时对象的生成，速度慢也占内存
    s1 + s2 = s2;
    string() = "Hello"
    //string().operator=("Hello");
    
    cout << &(s1 + s2) << endl;//报错，&必须左值
    cout << &(string(”Hello")) << endl;//报错，&必须左值
                     
    cout << &(string() = "Hello") << endl;
    string() = "Hello"
    //string().operator=("Hello");
    ```

## 7 移动构造

- 移动构造其实就是浅拷贝，简单的讲的话就是偷，以前我们都知道当一个类里面有指针，有用到new申请内存空间的时候，我们要注意把拷贝构造函数写成深拷贝，以防两个指针指向同一个地方，其中一个delete造成另一个指针变成野指针，但是那是建立在拷贝与被拷贝的两个对象在之后都会使用到的情况，如果我这个被拷贝的对象后面不用了，或者他就是一个临时对象，总之如果他就是一个右值的话，我们就可以直接浅拷贝，直接去偷它的东西，因为他以后不用了嘛，让我们的指针指向它的那块内存，在把它自己的指针指向null，这样就省去了一个创建临时对象的消耗
- 要注意的是，一定要置空，如果不置空，这个临时对象销毁的时候就会发生前面说的浅拷贝问题，置空之后我们析构里面写了如果指针为null就不会delete，
- 移动构造函数的参数就是一个右值引用

## 8 移动赋值

- `operator=`设计一个右值引用的模板

## 9完美转发

- 使用forward进行完美转发

- 不完美转发，假设有一个process函数，有两个版本，一个是处理左值的，一个是处理右值的，然后有一个中转站接收右值参数，在中转站里面再调用刚刚的process函数，会发现最后都会调用process的左值版本，说明中转站把右值参数变成了左值，这就改变了参数的性质，是不完美转发，那之所以会这样的原因，我个人觉得是因为当右值被引用之后，也就有了一个名字，编译器就认为它是个左值了

- 完美转发

  - ```c++
    void func(int& a, int& b)
    {
        cout << "错误" << endl;
    }
    void func(int& a, int&& b)
    {
        cout << "正确" << endl;
    }
    template<class T1,class T2>
    void forward_a(T1&& a, T2&& b) {
        func(forward<T1>(a), forward<T2>(b));
    }
    
    int main() {
        int i = 1;
        forward_a(i,1);
    
        system("pause");
    }
    ```

- 但是完美转发只生效一次，如是再嵌套一次函数调用，需要在使用一次forward

- 万能引用实现 ——引用折叠

## 10 for循环的优化

- ```c++
  for(auto a : b) {
  
  }
  //a遍历b中每一个值，但是这样无法传递数组
  
  void func(int b[]) {
      for(auto a : b ){}
  }//报错，因为a不知道b里面有几个
  
  void func(int (&b)[5]) {
      for(auto a : b){}
  }
  int main () {
      int b[5]{1,2,3,4,5};
      func(b);//成功，但是这样设计函数数必须知道数组的大小
  }
  
  template<class T,int N>
  void func(T (&b)[N]) {
      for(auto a : b){}
  }
  int main () {
      int b[5]{1,2,3,4,5};
      func(b);//成功设计了一个遍历任意数组大小的函数
  }
  ```

## 11 noexcept

```c++
void BlockThrowPro() noexcept
{
    throw 2;
}

```

## 12 nullptr

- 解决NULL和0的二义性，在C++中的NULL，如果去看它的源码，可以看到它就是一个宏定义，就是0，而如果我们一个函数重载的两个版本参数分别为指针和int，这个使用如果函数调用时传递的参数为NULL，就会有二义性，可能编译不通过，也可能回去调用int的版本。
- 所以c++引入了nullptr，这是一个关键字，我没找到它的源码，但是它的返回值应该是被限定在了指针上就没有二义性了

## 13 constexpr常量表达式

- 在编译阶段计算

## 14 final

- 阻止类进一步派生
- 阻止虚函数进一步重写

## 15 override

- 基类有一个虚函数，我们子类可以重写虚函数（参数类型一样），但是若是我们参数不小心写成不一样的，编译不会报错，但是这已经成为了重定义了，自动把父类同名函数隐藏而不是重写，在函数后面加上override，会让编译器检查，必须是重写
- 但是基类不能使用override，因为它是第一个虚函数

## 16 default和delete

- 在一个类中，我们写了一个有参构造函数时，默认构造函数就删除了，我们可以在默认构造函数中使用default，让他成为默认函数，效率比用户写的高

- 只能修饰系统默认的一些函数

```c++
class X
{ 
public: 
    X() = default  // 手动定义默认构造函数

    X(int i)
    { 
        a = i; 
    }
        
private: 
    int a; 
}; 

```

- 为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性："=delete"函数。程序员只需在函数声明后上“=delete;”，就可将该函数禁用。

```c++
class X
{
public:
    X();
    X(const X&) = delete;  // 声明拷贝构造函数为 deleted 函数
    X& operator = (const X &) = delete; // 声明拷贝赋值操作符为 deleted 函数
};

```

- "=delete"函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换：

```c++
class test1 {
public: 
    void func2(double);
    void func2(int) = delete;
};

int main() {
	test1 t;
	t.fun2(2);//报错，本来2应该能转换成2.0
}
```

- "=delete"函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象：

```c++
class X
{
public:
    void *operator new(size_t) = delete;
    void *operator new[](size_t) = delete;
};

int main()
{
    X *pa = new X;      // 错误，new 操作符被禁用
    X *pb = new X[10];  // 错误，new[] 操作符被禁用

    return 0;
}

```

## 17 类型的别名

- ```c++
  using uint = unsigned int;
  typedef unsigned int UINT;
  
  using sint = int;
  ```

## 18 函数模板的默认模板参数

- 普通函数 和 类模板 的默认参数必须从右往左排列
- 模板函数的默认模板参数没有顺序要求

## 19 可变参数的模板函数

- 可以接收任意个模板参数

```c++
template<class ... T> void func(T ... args)//T叫模板参数包，args叫函数参数包
{//可变参数模板函数

}

func();    // OK：args不含有任何实参
func(1);    // OK：args含有一个实参：int
func(2, 1.0);   // OK：args含有两个实参int和double

```

- 用sizeof...(args)计算参数个数

```c++
cout << "num = " << sizeof...(args) << endl;
```

- 通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。

```c++
//递归终止函数
void debug()
{
    cout << "empty\n";
}

//展开函数
template <class T, class ... Args>
void debug(T first, Args ... last)
{
    cout << "parameter " << first << endl;
    debug(last...);
}

```

- 非递归展开，借助逗号运算符和初始化列表

```c++
template <class T>
void print(T arg)
{
    cout << arg << endl;
}

template <class ... Args>
void expand(Args ... args)
{
    int a[] = { (print(args), 0)... };
}

int main()
{
    expand(1, 2, 3, 4);

    return 0;
}
```

## 20 可变参数的模板类

- 继承方式展开参数包

```c++
template<typename... A> class BMW{};  // 变长模板的声明

template<typename Head, typename... Tail>  // 递归的偏特化定义
class BMW<Head, Tail...> : public BMW<Tail...>
{//当实例化对象时，则会引起基类的递归构造
public:
    BMW()
    {
        printf("type: %s\n", typeid(Head).name());
    }

    Head head;
};

template<> class BMW<>{};  // 边界条件

int main()
{
    BMW<int, char, float> car;
    /*
    运行结果：
        type: f
        type: c
        type: i
    */

    return 0;
}
```

